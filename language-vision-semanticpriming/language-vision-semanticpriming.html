<!DOCTYPE html>
<html>

  <head>

    <!-- Load in jsPsych library and plugins -->
    <script src='https://unpkg.com/jspsych@7.3.1'></script>
    <script src='https://unpkg.com/@jspsych/plugin-html-keyboard-response@1.1.1'></script>
    <script src='https://unpkg.com/@jspsych/plugin-html-button-response@1.1.1'></script>
    <script src='https://unpkg.com/@jspsych/plugin-call-function@1.1.1'></script>
    <script src='https://unpkg.com/@jspsych-contrib/plugin-rok@1.1.1'></script>

    <!-- Load in jquery library -->
    <script src='https://ajax.googleapis.com/ajax/libs/jquery/3.6.3/jquery.min.js'></script>

    <!-- Load in semantic priming stimuli (tag: 'SemPri') -->
    <script src='js/semanticpriming_practice_stimuli.js'></script>
    <script src='js/semanticpriming_main_stimuli_1.js'></script>
    <script src='js/semanticpriming_main_stimuli_2.js'></script>

    <!-- Load in reading ability stimuli (tag: 'ReadAbil') -->
    <script src='js/reading_ability_stimuli.js'></script>

    <!-- Load in other tasks: visual ability (tag: 'VisAbil') 
    and working memory (tag: 'WorkMem') -->
    <script src='js/visual_ability_task.js'></script>
    <script src='js/working_memory_task.js'></script>

    <!-- Load in CSS -->
    <link rel='stylesheet' href='https://unpkg.com/jspsych@7.3.1/css/jspsych.css' />
    <link rel='stylesheet' href='style.css' />

  </head>


  <!-- Beginning of the script that contains the core of the experiment -->
  <script>
  
    // Prevent backing and refreshing (as in https://github.com/nivlab/jspsych-demos/blob/main/tasks/vocabulary/experiment.html)
    function verify_unload(e) {
      e.preventDefault();
      (e || window.event).returnValue = null;
      return null;
    };
    window.addEventListener('beforeunload', verify_unload);

    // Initialise experiment
    var jsPsych = initJsPsych({
      on_finish: function() {

        // Remove requirement to verify redirect
        window.removeEventListener('beforeunload', verify_unload);

        // Add interactions to the data variable
        var interaction_data = jsPsych.data.getInteractionData();
        jsPsych.data.get().addToLast({
          interactions: interaction_data.json()
        });

        jsPsych.data.displayData();
        jsPsych.data.get().csv();
      }
    });

    /* Create empty timeline object, which will be sequentially 
    filled in using language_vision_SemPri_TIMELINE.push() */
    var language_vision_SemPri_TIMELINE = [];

    // Assign random ID to participant, and record date and time
    jsPsych.data.addProperties({
      Participant: jsPsych.randomization.randomID(15),
      experiment_start: new Date().toUTCString()
    });


    // Create function to create range of numbers
    function makeArr(startValue, stopValue, cardinality) {
      var arr = [];
      var step = (stopValue - startValue) / (cardinality - 1);
      for (var i = 0; i < cardinality; i++) {
        arr.push(startValue + (step * i));
      }
      return arr;
    }


    /* Create short countdown to separate tasks (code adapted 
    from https://github.com/jspsych/jsPsych/discussions/1690) */

    var break_between_tasks = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: '<div>Task completed! The next task will begin in ' +
        "<b><span id='clock'>9</span> seconds</b>.</div>",
      choices: 'NO_KEYS',
      trial_duration: 9100, // must be slightly larger than timer below
      on_load: function() {
        var wait_time = 9000;
        var start_time = performance.now();
        var interval = setInterval(function() {
          var time_left = wait_time - (performance.now() - start_time);
          var seconds = Math.floor(time_left / 1000);
          var seconds_str = seconds.toString().padStart(1, '0');
          document.querySelector('#clock').innerHTML = seconds_str;
          if(time_left <= 0) {
            document.querySelector('#clock').innerHTML = '0';
            clearInterval(interval);
          }
        }, 250)
      }
    };
    
    
    /* Forty-second break to be used between Blocks 1 and 2 of semantic priming 
    (code adapted from https://github.com/jspsych/jsPsych/discussions/1690) */

    var break_between_blocks = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: "<div>Great job! It's time for a little break. The current " +
        "task will resume in <b><span id='clock'>40</span> seconds</b>.</div>",
      choices: 'NO_KEYS',
      trial_duration: 40100, // must be slightly larger than timer below
      on_load: function() {
        var wait_time = 40000;
        var start_time = performance.now();
        var interval = setInterval(function() {
          var time_left = wait_time - (performance.now() - start_time);
          var seconds = Math.floor(time_left / 1000);
          var seconds_str = seconds.toString().padStart(2, '0');
          document.querySelector('#clock').innerHTML = seconds_str;
          if(time_left <= 0) {
            document.querySelector('#clock').innerHTML = '00';
            clearInterval(interval);
          }
        }, 250)
      }
    };
    
    
    /* Instructional manipulation check abiding by Prolific's policy 
       (https://researcher-help.prolific.co/hc/en-gb/articles/360009223553) */

    // Random number for the instructional_manipulation_check below
    var random_number = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: '',
      trial_duration: 20,
      choices: 'NO_KEYS',
      on_finish: function(data) {
        data.random_number = Math.floor(Math.random() * (9999 - 1000 + 1) + 1000)
        data.random_position = jsPsych.randomization.sampleWithoutReplacement([0, 1, 2, 3], 1)[0]
      }
    };

    var instructional_manipulation_check = {
      type: jsPsychHtmlKeyboardResponse,
      trial_duration: 10000,
      data: { task: 'instructional_manipulation_check' },
      stimulus: function(data) {
        if(jsPsych.data.getLastTrialData().values()[0].random_position == 0) {
          return '<p>Performance has been low. Please enter the ' +
            '<b>first</b> number in the following sequence: ' +
            '<span style="font-weight:bold;">' +
            jsPsych.data.getLastTrialData().values()[0].random_number +
            '</span></p>'
        } else if(jsPsych.data.getLastTrialData().values()[0].random_position == 1) {
          return '<p>Performance has been low. Please enter the ' +
            '<b>second</b> number in the following sequence: ' +
            '<span style="font-weight:bold;">' +
            jsPsych.data.getLastTrialData().values()[0].random_number +
            '</span></p>'
        } else if(jsPsych.data.getLastTrialData().values()[0].random_position == 2) {
          return '<p>Performance has been low. Please enter the ' +
            '<b>third</b> number in the following sequence: ' +
            '<span style="font-weight:bold;">' +
            jsPsych.data.getLastTrialData().values()[0].random_number +
            '</span></p>'
        } else if(jsPsych.data.getLastTrialData().values()[0].random_position == 3) {
          return '<p>Performance has been low. Please enter the ' +
            '<b>fourth</b> number in the following sequence: ' +
            '<span style="font-weight:bold;">' +
            jsPsych.data.getLastTrialData().values()[0].random_number +
            '</span></p>'
        }
      },
      on_finish: function(data) {
        // Categorise passed check
        if(data.response ==
        jsPsych.data.get().last(2).values()[0].random_number.toString().charAt(jsPsych.data.get().last(2).values()[0].random_position)) {
          data.instructional_manipulation_check = 'passed'
          // Categorise failed check
          } else data.instructional_manipulation_check = 'failed';
          // Terminate experiment if two instructional manipulation checks have been failed
          if(jsPsych.data.get().filter({
            instructional_manipulation_check: 'failed'
            }).count() == 2) {
              jsPsych.endExperiment('<div>Unfortunately, the experiment cannot continue because ' +
              'two instructional manipulation checks have been failed. Please return to Prolific ' +
              'and click <button>Stop without Completing</button>. ' +
              '<a href="https://app.prolific.co/submissions/complete?cc=CBXBRKZI">Click here to ' +
              'return to <b>Prolific</b></a>. Thank you very much.</div>', data)
        }
      }
    };



    /* The experiment contains two comprehension checks abiding by Prolific's 
    policy (https://researcher-help.prolific.co/hc/en-gb/articles/360009223553).
    The checks appear at the beginning of the experiment. If two attempts are 
    failed, the experiment ends and the participant is asked to return to 
    Prolific and click on 'Stop without Completing'. The first check corresponds 
    to the working memory task. The second check corresponds to the reading 
    ability task. */
    

    /****************************************************/
    /**  COMPREHENSION CHECK FOR WORKING MEMORY TASK   **/
    /****************************************************
    
    // Push task to general timeline
    language_vision_SemPri_TIMELINE.push(working_memory_practice);  // from working_memory_task.js
    
    // Transition to next task
    language_vision_SemPri_TIMELINE.push(break_between_tasks);
    
    

    /**********************************************/
    /** READING ABILITY TASK (tag: 'ReadAbil')   **/
    /**********************************************/

    /***
    This reading ability assessment is based on a lexical decision task,
    supported by the findings of Yeatman et al. (2021;
    https://doi.org/10.1038/s41598-021-85907-x). The stimuli are also
    based on the materials of Yeatman et al. (see the script
    'reading_ability_stimulus_preparation.R' in the 'data' folder). The 
    stimuli created in 'ReadAbil_stimulus_preparation.R' are stored in
    'reading_ability_stimuli.js', and that script is loaded into the 
    present experiment. 
    
    Begin programming the reading ability task by creating the 
    components of the lexical decision trials. These components will 
    be used in the practice block and in the main block. Some 
    components are only used in a certain block. For instance, the 
    instructions and the feedback are only shown in the practice. 
    Another key difference across the different blocks is the 
    `timeline_variables` they use. The practice block uses 
    `ReadAbil_practice_stimuli`, whereas the main block uses 
    `ReadAbil_main_STIMULI`.
    ***/

    var ReadAbil_instructions = {
      type: jsPsychHtmlKeyboardResponse,
      prompt: '<p>Press the space bar to begin.</p>',
      choices: [' '],
      trial_duration: 15000,
      stimulus: [
        '<div>Welcome to the first task.<br>Each screen will show a string of letters. Please ' +
        'press <button>J</button> if the letters form a real word (for instance, <i>flask</i>), or ' +
        'press <button>F</button> if they do <i>not</i> (for instance, <i>wreet</i>). Please only ' +
        'respond once you see the letters. At that point, try to respond as accurately and ' +
        'fast as possible. Next, you can practise with some trials.</div>'
      ]
    };
    // Push to general timeline
    language_vision_SemPri_TIMELINE.push(ReadAbil_instructions);

    // Fixation cross
    var ReadAbil_fixation = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: '+',
      // Choices set below to allow logging any premature response attempts
      choices: ['f', 'j'],
      response_ends_trial: false,
      trial_duration: function() {
        // Set fixations with a varying duration to boost participants' attention
        return jsPsych.randomization.sampleWithoutReplacement([400, 450, 500, 550, 600], 1)[0];
      },
      data: {
        task: jsPsych.timelineVariable('task'),
        trial: jsPsych.timelineVariable('trial')
      },
      css_classes: ['stimulus'],
      // Bespoke data to be included in output
      on_finish: function(data) {
        // Log premature response attempts by writing 1
        if(data.response != null) {
          data.premature_response_attempts = 1;
        } else {
          data.premature_response_attempts = 0
        }
      }
    };

    /* Register any premature response attempts during the first 150 ms after
    onset of the stimulus. These attempts are not considered as responses. */

    var stim_150ms = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: jsPsych.timelineVariable('stim'),
      // Choices set below to allow logging any premature response attempts
      choices: ['f', 'j'],
      response_ends_trial: false,
      trial_duration: 150,
      data: {
        task: jsPsych.timelineVariable('task'),
        trial: jsPsych.timelineVariable('trial')
      },
      css_classes: ['stimulus'],
      // Bespoke data to be included in output
      on_finish: function(data) {
        // Log premature response attempts by writing 1
        if(data.response != null) {
          data.premature_response_attempts = 1;
        } else {
          data.premature_response_attempts = 0
        }
      }
    };

    /* In the stim section of trials, all the key data are gathered, 
    including information from previous sections of the same trial. */

    var stim = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: function() {
        // In practice section, present instructions above prime word
        if(jsPsych.timelineVariable('task') == 'ReadAbil_practice') {
          return '<div><b>Reminder:</b> press <button>F</button> if the letters below ' +
            'form a real word (for instance, <i>flask</i>) or press <button>J</button> ' +
            'if they do <i><b>not</i></b> (for instance, <i>wreet</i>). Please respond ' +
            'as accurately and fast as possible.</div>' +
            '<div style="text-align:center; font-size: 105%;">' +
            jsPsych.timelineVariable('stim') +
            '</div>'
        } else {
          return jsPsych.timelineVariable('stim')
        }
      },
      choices: ['f', 'j'],
      /* Set 3,000 ms as the maximum trial duration, the same as in the lexical decision 
      task of Hutchison et al. (2013; https://doi.org/10.3758/s13428-012-0304-z) and in 
      the semantic decision task of Pexman et al. (2017; https://doi.org/10.3758/s13428-016-0720-6). 
      In the practice trials, prolong the duration. */
      trial_duration: function() {
        if(jsPsych.timelineVariable('task') == 'ReadAbil_practice') {
          return 40000
        } else {
          return 2850
        }
      },
      css_classes: ['stimulus'],
      data: { // add info to output
        task: jsPsych.timelineVariable('task'),
        trial: jsPsych.timelineVariable('trial'),
        stim: jsPsych.timelineVariable('stim'),
        corr_rsp: jsPsych.timelineVariable('corr_rsp')
      },

      // Bespoke data to be included in output
      on_finish: function(data) {

        if(data.response != null) {
          // Label correct responses
          if((data.corr_rsp == 'no' && data.response == 'f') ||
            (data.corr_rsp == 'yes' && data.response == 'j')) {
            data.accuracy = 'correct'
            // Label incorrect responses
          } else if((data.corr_rsp == 'no' && data.response == 'j') ||
            (data.corr_rsp == 'yes' && data.response == 'f')) {
            data.accuracy = 'incorrect'
          }
          // Label unanswered trials
        } else {
          data.accuracy = 'unanswered'
        };

        // Overall accuracy rate so far, ranging between 0 and 1

        var ReadAbil_total_correct =
          jsPsych.data.get().filter({
            task: jsPsych.timelineVariable('task'),
            accuracy: 'correct'
          }).count();
        var ReadAbil_total_incorrect =
          jsPsych.data.get().filter({
            task: jsPsych.timelineVariable('task'),
            accuracy: 'incorrect'
          }).count();
        var ReadAbil_total_unanswered =
          jsPsych.data.get().filter({
            task: jsPsych.timelineVariable('task'),
            accuracy: 'unanswered'
          }).count();

        data.accuracy_rate =
          ReadAbil_total_correct /
          (ReadAbil_total_correct +
            ReadAbil_total_incorrect +
            ReadAbil_total_unanswered);

        /* Aggregate any premature response attempts on this trial. 
        If there were any, write 'yes'. */

        if(jsPsych.data.get().last(3).values()[0].premature_response_attempts != 0 ||
          jsPsych.data.get().last(2).values()[0].premature_response_attempts != 0) {
          data.premature_response_attempts = 'yes';
        } else {
          data.premature_response_attempts = 'no'
        };
      }
    };

    // On selected trials, administer instructional manipulation check if accuracy rate < 80%
    var ReadAbil_conditional_instructional_manipulation_check = {
      timeline: [random_number, instructional_manipulation_check],
      on_timeline_start: function(data) {
        console.log(jsPsych.data.getLastTrialData().values()[0].accuracy_rate);
        console.log(jsPsych.data.getLastTrialData().values()[0].trial)
      },
      /* On selected trials, if last trial was incorrect, and average accuracy < .8,
      administer instructional manipulation check. */
      conditional_function: function(data) {
        if([10, 20, 40, 60, 80].includes(jsPsych.data.getLastTrialData().values()[0].trial) &&
          jsPsych.data.getLastTrialData().values()[0].accuracy != 'correct' &&
          jsPsych.data.getLastTrialData().values()[0].accuracy_rate < .8) {
          return true;
        } else {
          return false
        }
      }
    };

    var ReadAbil_feedback = {
      type: jsPsychHtmlKeyboardResponse,
      data: {
        task: jsPsych.timelineVariable('task'),
        trial: jsPsych.timelineVariable('trial')
      },
      stimulus: function() {
        var last_trial_accuracy =
          jsPsych.data.getLastTrialData().values()[0].accuracy;
        if(last_trial_accuracy == 'correct') {
          return '<p><green-button> &check; </green-button></p>'
        } else if(last_trial_accuracy == 'incorrect') {
          return '<p><red-button> &#x2718; </red-button></p>'
        } else if(last_trial_accuracy == 'unanswered') {
          return '<p><red-button> 0 </red-button></p>'
        }
      },
      choices: 'NO_KEYS',
      trial_duration: 800
    };

    // The intertrial interval is the last part of every trial
    var ReadAbil_intertrial_interval = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: ' ',
      trial_duration: function() {
        // Set interval with a varying duration to boost participants' attention
        return jsPsych.randomization.sampleWithoutReplacement([1400, 1450, 1500, 1550, 1600], 1)[0];
      },
      data: {
        task: jsPsych.timelineVariable('task'),
        trial: jsPsych.timelineVariable('trial')
      },
      response_ends_trial: false,
      css_classes: ['stimulus']
    };


    // PRACTICE TRIALS

    /* Two trials used as practice stimuli. Neither of these stimuli are present 
    in the main part of the reading ability task or in the semantic priming task. */

    var ReadAbil_practice_stimuli = [{
        'stim': 'wreet',
        'corr_rsp': 'no',
        'task': 'ReadAbil_practice',
        'trial': 1
      },
      {
        'stim': 'flask',
        'corr_rsp': 'yes',
        'task': 'ReadAbil_practice',
        'trial': 2
      }
    ];

    /* Assemble practice trials timeline using some of the components 
    created at the top of this script. */

    var ReadAbil_practice_timeline = {
      timeline: [ ReadAbil_fixation, stim_150ms, stim,
        ReadAbil_feedback, ReadAbil_intertrial_interval ],
      timeline_variables: ReadAbil_practice_stimuli
    };
    // Push to general timeline
    language_vision_SemPri_TIMELINE.push(ReadAbil_practice_timeline);

    // Overall feedback on all the initial practice trials
    var ReadAbil_practice_debrief = {
      type: jsPsychHtmlKeyboardResponse,
      choices: [' '],
      trial_duration: 40000,

      stimulus: function() {

        var ReadAbil_practice_trials_total_correct =
          jsPsych.data.get().filter({
            task: 'ReadAbil_practice',
            accuracy: 'correct'
          }).count();
        var ReadAbil_practice_trials_total_incorrect =
          jsPsych.data.get().filter({
            task: 'ReadAbil_practice',
            accuracy: 'incorrect'
          }).count();
        var ReadAbil_practice_trials_total_unanswered =
          jsPsych.data.get().filter({
            task: 'ReadAbil_practice',
            accuracy: 'unanswered'
          }).count();
        var ReadAbil_practice_trials_accuracy_rate =
          ReadAbil_practice_trials_total_correct /
          (ReadAbil_practice_trials_total_correct +
            ReadAbil_practice_trials_total_incorrect +
            ReadAbil_practice_trials_total_unanswered);

        // Tailor message to the results
        
        // If more than one comprehension checks were failed, stop experiment
        if(jsPsych.data.get().filter({
              task: 'ReadAbil_practice',
              accuracy: 'unanswered'
              }).count() +
              jsPsych.data.get().filter({
                task: 'ReadAbil_practice',
                accuracy: 'incorrect'
                }).count() > 1) {
                  return '<div>Unfortunately, the experiment cannot continue because two ' +
                  'comprehension checks were failed. Please return to Prolific and click ' +
                  '<button>Stop without Completing</button>. ' +
                  '<a href="https://app.prolific.co/submissions/complete?cc=CBXBRKZI"> ' +
                  'Click here to return to <b>Prolific</b></a>. Thank you very much.</div><br>'
        
        // If results good, keep message short
        } else if(jsPsych.data.get().filter({
          premature_response_attempts: 'yes'
          }).count() == 0 &&
          ReadAbil_practice_trials_accuracy_rate >= .8) {
            return '<div>Practice completed. In the next part, neither the instructions ' +
            'nor the feedback will be shown, and trials will be faster. Please press the ' +
            'space bar to begin.</div>'

          // If results valid but not so good, present them
        } else {
          var message =
            '<div><b>Results of the practice</b><br>' +
            'Your accuracy rate was ' +
            Math.round(ReadAbil_practice_trials_accuracy_rate * 100) + '%' +
            ' (' + ReadAbil_practice_trials_total_correct + ' correct trials, ' +
            ReadAbil_practice_trials_total_incorrect + ' incorrect and ' +
            ReadAbil_practice_trials_total_unanswered + ' unanswered).</div>'

          // Report any premature response attempts

          if(jsPsych.data.get().filter({
              premature_response_attempts: 'yes'
            }).count() == 1) {
            var message = message +
              '<div>There was a response attempt before the word had been presented. ' +
              'Please respond only when the word appears on the screen.</div>';

          } else if(jsPsych.data.get().filter({
              premature_response_attempts: 'yes'
            }).count() > 1) {
            var message = message +
              '<div>There were ' +
              jsPsych.data.get().filter({
                premature_response_attempts: 'yes'
              }).count() +
              ' response attempts before the word had been presented. Please ' +
              'respond only when the word appears on the screen.</div>';
          }

          // Display entire message
          return message +
            '<div>Please press the space bar to repeat the practice.</div>'
        }
      },

      on_finish: function(data) {
        if(jsPsych.data.get().filter({
              task: 'ReadAbil_practice',
              accuracy: 'unanswered'
              }).count() +
              jsPsych.data.get().filter({
                task: 'ReadAbil_practice',
                accuracy: 'incorrect'
                }).count() > 1) {
          jsPsych.endExperiment('<div>Unfortunately, the experiment cannot continue because ' +
          'two comprehension checks have been failed. Please return to Prolific and click ' +
          '<button>Stop without Completing</button>. ' +
          '<a href="https://app.prolific.co/submissions/complete?cc=CBXBRKZI">Click here to ' +
          'return to <b>Prolific</b></a>. Thank you very much.</div>', data)
        }
      }
    };
    // Push to general timeline
    language_vision_SemPri_TIMELINE.push(ReadAbil_practice_debrief);

    // Prepare repeated instructions
    var repeat_ReadAbil_instructions = {
      type: jsPsychHtmlKeyboardResponse,
      prompt: '<p>Press the space bar to begin.</p>',
      choices: [' '],
      trial_duration: 40000,
      stimulus: [
        '<div>Please consider the instructions again. Each screen will show a string of ' +
        'letters. Please press <button>J</button> if the letters form a real word (for ' +
        'instance, <i>flask</i>), or press <button>F</button> if they do <i><b>not</i></b> ' +
        '(for instance, <i>wreet</i>). Please try to respond as accurately and fast as ' +
        'possible.</div>'
      ]
    };

    /* Present repeated instructions if there were any premature 
    response attempts or if accuracy rate < 65%. */
    var conditional_repeat_ReadAbil_instructions = {
      timeline: [repeat_ReadAbil_instructions],
      conditional_function: function() {
        if(jsPsych.data.get().filter({
            premature_response_attempts: 'yes'
          }).count() > 0 ||
          jsPsych.data.get().last(4).values()[0].accuracy_rate < .8) {
          return true;
        } else {
          return false
        }
      }
    };
    // Push to general timeline
    language_vision_SemPri_TIMELINE.push(conditional_repeat_ReadAbil_instructions);

    /* Repeat practice trials if there were any premature 
    response attempts or if accuracy rate < 65%. */
    var ReadAbil_repeated_practice_trials = {
      timeline: [ReadAbil_practice_timeline],
      data: {
        practice_round: 2
      },
      conditional_function: function() {
        if(jsPsych.data.get().filter({
            premature_response_attempts: 'yes'
          }).count() > 0 ||
          jsPsych.data.get().last(5).values()[0].accuracy_rate < .8) {
          return true;
        } else {
          return false
        }
      }
    };
    // Push to general timeline
    language_vision_SemPri_TIMELINE.push(ReadAbil_repeated_practice_trials);

    // Overall feedback on all the repeated practice trials
    var ReadAbil_repeated_practice_debrief = {
      type: jsPsychHtmlKeyboardResponse,
      choices: [' '],
      trial_duration: 20000,

      stimulus: function() {

        // Tailor message introduction to the results
        if(jsPsych.data.get().filter({
            task: 'ReadAbil_practice',
            accuracy: 'unanswered'
          }).count() +
          jsPsych.data.get().filter({
            task: 'ReadAbil_practice',
            accuracy: 'incorrect'
          }).count() < 2) {

          // Begin message (div closed below)
          var message = '<div>Practice completed. '

          // Report any premature response attempts

          if(jsPsych.data.get().filter({
              task: 'ReadAbil_practice',
              premature_response_attempts: 'yes'
            }).count() == 1) {
            var message = message +
              '<br>There was a response attempt before the word had been presented. ' +
              'Please respond only when the word appears on the screen.<br>';

          } else if(jsPsych.data.get().filter({
              task: 'ReadAbil_practice',
              practice_round: 2,
              premature_response_attempts: 'yes'
            }).count() > 1) {
            var message = message +
              '<br>There were ' +
              jsPsych.data.get().filter({
                task: 'ReadAbil_practice',
                premature_response_attempts: 'yes'
              }).count() +
              ' response attempts before the word had been presented. ' +
              'Please respond only when the word appears on the screen.<br>';
          }

          // Finish message and display it
          return message + 'In the next part, neither the instructions nor the ' +
            'feedback will be shown, and trials will be faster. Please press ' +
            'the space bar to begin.</div><br>'

          /* Specify feedback if more than one comprehension checks were failed, 
          in which case the experiment must be terminated. */
        } else {
          return '<div>Unfortunately, the experiment cannot continue because two ' +
            'comprehension checks have been failed. Please return to Prolific ' +
            'and click <button>Stop without Completing</button>. ' +
            '<a href="https://app.prolific.co/submissions/complete?cc=CBXBRKZI"> ' +
            'Click here to return to <b>Prolific</b></a>. Thank you very much.' +
            '</div><br>'
        }
      },

      on_finish: function(data) {
        if(jsPsych.data.get().filter({
            accuracy: 'incorrect'
          }).count() > 1) {
          jsPsych.endExperiment('<div>Unfortunately, the experiment cannot continue because ' +
          'two comprehension checks have been failed. Please return to Prolific and click ' +
          '<button>Stop without Completing</button>. ' +
          '<a href="https://app.prolific.co/submissions/complete?cc=CBXBRKZI">Click here to ' +
          'return to <b>Prolific</b></a>. Thank you very much.</div>', data)
        }
      }
    };

    // Show second-round feedback if practice trials were repeated
    var conditional_ReadAbil_repeated_practice_debrief = {
      timeline: [ReadAbil_repeated_practice_debrief],
      conditional_function: function() {
        if(jsPsych.data.get().filter({
            task: 'ReadAbil_practice',
            practice_round: 2
          }).count() >= 1) {
          return true;
        } else {
          return false
        }
      },
      repetitions: 1
    };
    // Push to general timeline
    language_vision_SemPri_TIMELINE.push(conditional_ReadAbil_repeated_practice_debrief);


    // MAIN TRIALS

    /* Create timeline variable iteratively over trials using a for-of loop. 
    Two preparatory steps are performed before running the loop. */

    // 1. Initialise ReadAbil_STIMULI array
    ReadAbil_STIMULI = [];

    // 2. Randomise trial order

    var trial_order =
      Array.from({
        length: ReadAbil_stimuli.length
      }, (v, k) => k * 1);

    var randomised_trial_order =
      jsPsych.randomization.sampleWithoutReplacement(trial_order,
        ReadAbil_stimuli.length);

    // 3. Run loop
    for (const i of randomised_trial_order) {
      ReadAbil_STIMULI.push({
        task: 'ReadAbil',
        stim: ReadAbil_stimuli[i].stim,
        corr_rsp: ReadAbil_stimuli[i].corr_rsp
      })
    }

    /* Create trial numbers iteratively. Important: the names of three variables 
    used below ('prime', 'target', 'corr_rsp') were set in the for loops above. */

    var temp_ReadAbil_STIMULI = [];

    // 1. Create function to create iterable range
    const Range = (start, end) => ({
      *[Symbol.iterator]() {
        while (start < end)
          yield start++;
      }
    })

    for (const i of Range(0, ReadAbil_STIMULI.length)) {
      temp_ReadAbil_STIMULI.push({
        task: 'ReadAbil',
        trial: i + 1, // 1 added to override the default start from 0
        stim: ReadAbil_STIMULI[i].stim,
        corr_rsp: ReadAbil_STIMULI[i].corr_rsp // correct response
      })
    }

    var ReadAbil_STIMULI = temp_ReadAbil_STIMULI;


    /* Assemble main trials timeline using some of the 
    components created near the top of this script. */

    var ReadAbil_timeline = {
      timeline: [ ReadAbil_fixation, stim_150ms, stim,
        ReadAbil_conditional_instructional_manipulation_check,
        ReadAbil_intertrial_interval ],
      timeline_variables: ReadAbil_STIMULI
    };
    // Push to general timeline
    language_vision_SemPri_TIMELINE.push(ReadAbil_timeline);

    // Transition to next task
    language_vision_SemPri_TIMELINE.push(break_between_tasks);



    /********************************************/
    /** WORKING MEMORY TASK (tag: 'WorkMem')   **/
    /********************************************/

    // Push task to general timeline
    language_vision_SemPri_TIMELINE.push(working_memory_task); // from working_memory_task.js

    // Transition to next task
    language_vision_SemPri_TIMELINE.push(break_between_tasks);



    /**********************************************/
    /** SEMANTIC PRIMING TASK (tag: 'SemPri')   **/
    /**********************************************/

    /*
    Create components of the semantic priming trials. These components will be 
    used in the practice block and in the main blocks. Some components are 
    only used in a certain block. For instance, the instructions and the 
    feedback are only shown in the practice. Another key difference across the 
    different blocks is the `timeline_variables` they use. The practice block 
    uses `SemPri_practice_STIMULI`, Block 1 uses `SemPri_Block1_STIMULI`, and 
    Block 2 uses `SemPri_Block1_STIMULI`.
    */

    var SemPri_instructions = {
      type: jsPsychHtmlKeyboardResponse,
      prompt: '<p>Press the space bar to begin.</p>',
      choices: [' '],
      trial_duration: 40000,
      stimulus: [
        '<div>Each screen will first show a word in upper case very briefly, and afterwards, ' +
        'a word in lower case. Please read both words. When you see the lowercase word, ' +
        'please classify it as abstract or concrete. Abstract concepts are those that we ' +
        'cannot normally experience physically, whereas concrete concepts are those that ' +
        'we can experience more directly. Press <button>F</button> if the lowercase word ' +
        'is primarily abstract (for instance, <i>wait</i>), or press <button>J</button> if it ' +
        'is primarily concrete (for instance, <i>water</i>). Please try to respond as accurately ' +
        'and fast as possible. Next, you can practise with some trials. Correct ' +
        'responses will be indicated with <green-button> &check; </green-button>; ' +
        'incorrect responses with <red-button> &#x2718; </red-button>; and unanswered ' +
        'trials with <red-button> 0 </red-button>.<br></div>'
      ]
    };
    // Add to general timeline
    language_vision_SemPri_TIMELINE.push(SemPri_instructions);


    // Fixation cross
    var SemPri_fixation = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: '+',
      // Choices set below to allow logging any premature response attempts
      choices: ['f', 'j'],
      response_ends_trial: false,
      trial_duration: function() {
        // Set fixations with a varying duration to boost participants' attention
        return jsPsych.randomization.sampleWithoutReplacement([400, 450, 500, 550, 600], 1)[0];
      },
      data: { trial: jsPsych.timelineVariable('trial') },
      css_classes: ['stimulus'],
      // Bespoke data to be included in output
      on_finish: function(data) {
        // Track progress in the console
        console.log(
          'Trial ' + jsPsych.data.getLastTrialData().values()[0].trial +
          ', Minute ' +
          Math.round(jsPsych.data.getLastTrialData().values()[0].time_elapsed / 60000)
        );
        // Log premature response attempts by writing 1
        if(data.response != null) {
          data.premature_response_attempts = 1;
        } else {
          data.premature_response_attempts = 0
        }
      }
    };

    var prime = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: jsPsych.timelineVariable('prime'),
      // Choices set below to allow logging any premature response attempts
      choices: ['f', 'j'],
      response_ends_trial: false,
      trial_duration: 150,
      data: { trial: jsPsych.timelineVariable('trial') },
      css_classes: ['stimulus'],
      // Bespoke data to be included in output
      on_finish: function(data) {
        // Log premature response attempts by writing 1
        if(data.response != null) {
          data.premature_response_attempts = 1;
        } else {
          data.premature_response_attempts = 0
        }
      }
    };

    var ISInterval = {
      type: jsPsychHtmlKeyboardResponse,
      trial_duration: jsPsych.timelineVariable('ISInterval'),
      response_ends_trial: false,
      stimulus: ' ',
      // Choices set below to allow logging any premature response attempts
      choices: ['f', 'j'],
      data: { // add info to output
        trial: jsPsych.timelineVariable('trial'),
        ISInterval: jsPsych.timelineVariable('ISInterval')
      },
      css_classes: ['stimulus'],
      // Bespoke data to be included in output
      on_finish: function(data) {
        // Log premature response attempts by writing 1
        if(data.response != null) {
          data.premature_response_attempts = 1;
        } else {
          data.premature_response_attempts = 0
        }
      }
    };

    /* Register any premature response attempts during the first 150 ms after
    onset of the target word. These attempts are not considered as responses. */

    var target_150ms = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: jsPsych.timelineVariable('target'),
      // Choices set below to allow logging any premature response attempts
      choices: ['f', 'j'],
      response_ends_trial: false,
      trial_duration: 150,
      data: { trial: jsPsych.timelineVariable('trial') },
      css_classes: ['stimulus'],
      // Bespoke data to be included in output
      on_finish: function(data) {
        // Log premature response attempts by writing 1
        if(data.response != null) {
          data.premature_response_attempts = 1;
        } else {
          data.premature_response_attempts = 0
        }
      }
    };

    /* In the target word section of trials, all the key data are gathered, 
    including information from previous sections of the same trial, such 
    as the prime word and the interstimulus interval. */

    var target = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: jsPsych.timelineVariable('target'),
      choices: ['f', 'j'],
      /* Set 3,000 ms as the maximum trial duration, the same as in the lexical decision task
      of Hutchison et al. (2013; https://doi.org/10.3758/s13428-012-0304-z) and the semantic 
      decision task of Pexman et al. (2017; https://doi.org/10.3758/s13428-016-0720-6). */
      trial_duration: 2850,
      css_classes: ['stimulus'],
      data: { // add info to output
        task: jsPsych.timelineVariable('task'),
        trial: jsPsych.timelineVariable('trial'),
        prime: jsPsych.timelineVariable('prime'),
        target: jsPsych.timelineVariable('target'),
        corr_rsp: jsPsych.timelineVariable('corr_rsp'),
        ISInterval: jsPsych.timelineVariable('ISInterval')
      },

      // Bespoke data to be included in output
      on_finish: function(data) {

        if(data.response != null) {
          // Label correct responses
          if((data.corr_rsp == 'A' && data.response == 'f') ||
            (data.corr_rsp == 'C' && data.response == 'j')) {
            data.accuracy = 'correct'
            // Label incorrect responses
          } else if((data.corr_rsp == 'A' && data.response == 'j') ||
            (data.corr_rsp == 'C' && data.response == 'f')) {
            data.accuracy = 'incorrect'
          }
          // Label unanswered trials
        } else {
          data.accuracy = 'unanswered'
        };

        // Overall accuracy rate so far, ranging between 0 and 1

        var SemPri_total_correct =
          jsPsych.data.get().filter({
            task: jsPsych.timelineVariable('task'),
            accuracy: 'correct'
          }).count();
        var SemPri_total_incorrect =
          jsPsych.data.get().filter({
            task: jsPsych.timelineVariable('task'),
            accuracy: 'incorrect'
          }).count();
        var SemPri_total_unanswered =
          jsPsych.data.get().filter({
            task: jsPsych.timelineVariable('task'),
            accuracy: 'unanswered'
          }).count();

        data.accuracy_rate =
          SemPri_total_correct /
          (SemPri_total_correct +
            SemPri_total_incorrect +
            SemPri_total_unanswered);

        /* Aggregate any premature response attempts on this trial. 
        If there were any, write 'yes'. */

        if(jsPsych.data.get().last(5).values()[0].premature_response_attempts != 0 ||
          jsPsych.data.get().last(4).values()[0].premature_response_attempts != 0 ||
          jsPsych.data.get().last(3).values()[0].premature_response_attempts != 0 ||
          jsPsych.data.get().last(2).values()[0].premature_response_attempts != 0) {
          data.premature_response_attempts = 'yes';
        } else {
          data.premature_response_attempts = 'no'
        };

        /* By default, when all trials have been presented, the task will end. 
        In addition, a further condition is established below--namely, the 
        task will end if the start time of the last task is reached. */

        if(jsPsych.data.getLastTrialData().values()[0].time_elapsed >=
          time_to_begin_last_task) {
          jsPsych.endCurrentTimeline();
        }
      }
    };

    // On selected trials, administer instructional manipulation check if accuracy rate < 80%
    var SemPri_conditional_instructional_manipulation_check = {
      timeline: [random_number, instructional_manipulation_check],
      on_timeline_start: function(data) {
        console.log(jsPsych.data.getLastTrialData().values()[0].accuracy_rate);
        console.log(jsPsych.data.getLastTrialData().values()[0].trial)
      },
      /* On selected trials, if last trial was incorrect, and average accuracy < .8,
      administer instructional manipulation check. */
      conditional_function: function(data) {
        if([10, 20, 40, 60, 80, 100, 120, 140, 160, 180, 200].includes(jsPsych.data.getLastTrialData().values()[0].trial) &&
          jsPsych.data.getLastTrialData().values()[0].accuracy != 'correct' &&
          jsPsych.data.getLastTrialData().values()[0].accuracy_rate < .65) {
          return true;
        } else {
          return false
        }
      }
    };

    var SemPri_feedback = {
      type: jsPsychHtmlKeyboardResponse,
      data: { trial: jsPsych.timelineVariable('trial') },
      stimulus: function() {
        var last_trial_accuracy =
          jsPsych.data.getLastTrialData().values()[0].accuracy;
        if(last_trial_accuracy == 'correct') {
          return '<p><green-button> &check; </green-button></p>'
        } else if(last_trial_accuracy == 'incorrect') {
          return '<p><red-button> &#x2718; </red-button></p>'
        } else if(last_trial_accuracy == 'unanswered') {
          return '<p><red-button> 0 </red-button></p>'
        }
      },
      choices: 'NO_KEYS',
      trial_duration: 800
    };

    // The intertrial interval is the last part of every trial
    var SemPri_intertrial_interval = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: ' ',
      trial_duration: function() {
        // Set interval with a varying duration to boost participants' attention
        return jsPsych.randomization.sampleWithoutReplacement([1400, 1450, 1500, 1550, 1600], 1)[0];
      },
      data: { trial: jsPsych.timelineVariable('trial') },
      response_ends_trial: false,
      css_classes: ['stimulus']
    };



    /*********************************************
    
      Semantic priming PRACTICE trials
    
    *********************************************/


    /* First, create set of interstimulus intervals from a range between 60 and 
    1,200 ms. First, the range is split into as many integers as the minimum 
    number of trials, equally for all participants. Afterwards, all SOAs are 
    randomised within participants. */

    // Create range of SOAs
    ISIntervals_practice_trials =
      makeArr(60, 1200, SemPri_practice_stimuli.length);

    // Randomise SOAs (hence the .5 below)
    ISIntervals_practice_trials =
      ISIntervals_practice_trials.sort(function() {
        return 0.5 - Math.random()
      });

    /* Repeat the random sequence of SOAs to cater for the 
    repetition of the practice trials, which happens when 
    the first round is insufficient. */
    var ISIntervals_practice_trials =
      new Array(SemPri_practice_stimuli.length).fill(ISIntervals_practice_trials).flat();


    /* Create timeline variable iteratively over trials using a for-of loop. 
    Two preparatory steps are performed before running the loop. */

    // 1. Initialise SemPri_practice_STIMULI array
    SemPri_practice_STIMULI = [];

    // 2. Randomise trial order

    var trial_order =
      Array.from({
        length: SemPri_practice_stimuli.length
      }, (v, k) => k * 1);

    var randomised_trial_order =
      jsPsych.randomization.sampleWithoutReplacement(trial_order,
        SemPri_practice_stimuli.length);

    // 3. Run loop. Names of some variables are expanded.
    for (const i of randomised_trial_order) {
      SemPri_practice_STIMULI.push({
        task: 'SemPri_practice',
        prime: SemPri_practice_stimuli[i].PW, // name changed to 'prime'
        target: SemPri_practice_stimuli[i].TW, // name changed to 'target'
        corr_rsp: SemPri_practice_stimuli[i].CR, // name changed to 'corr_rsp', correct response
        ISInterval: ISIntervals_practice_trials[i]
      })
    }

    /* Create trial numbers iteratively. Important: the names of three variables 
    used below ('prime', 'target', 'corr_rsp') were set in the for loops above. */

    var temp_SemPri_practice_STIMULI = [];

    // 1. Use `range` function created above

    for (const i of Range(0, SemPri_practice_STIMULI.length)) {
      temp_SemPri_practice_STIMULI.push({
        task: 'SemPri_practice',
        trial: i + 1, // 1 added to override the default start from 0
        prime: SemPri_practice_STIMULI[i].prime, // prime word
        target: SemPri_practice_STIMULI[i].target, // target word
        corr_rsp: SemPri_practice_STIMULI[i].corr_rsp, // correct response
        ISInterval: ISIntervals_practice_trials[i]
      })
    }

    var SemPri_practice_STIMULI = temp_SemPri_practice_STIMULI;


    /* Assemble practice trials timeline using some of the components 
    created near the top of this script. */

    var SemPri_practice_timeline = {
      timeline: [ SemPri_fixation, prime, ISInterval, target_150ms, 
        target, SemPri_feedback, SemPri_intertrial_interval ],
      timeline_variables: SemPri_practice_STIMULI
    };
    // Add to general timeline
    language_vision_SemPri_TIMELINE.push(SemPri_practice_timeline);


    // Overall feedback on all the initial practice trials
    var SemPri_practice_debrief = {
      type: jsPsychHtmlKeyboardResponse,
      choices: [' '],
      trial_duration: 40000,

      stimulus: function() {

        var SemPri_practice_trials_total_correct =
          jsPsych.data.get().filter({
            task: 'SemPri_practice',
            accuracy: 'correct'
          }).count();
        var SemPri_practice_trials_total_incorrect =
          jsPsych.data.get().filter({
            task: 'SemPri_practice',
            accuracy: 'incorrect'
          }).count();
        var SemPri_practice_trials_total_unanswered =
          jsPsych.data.get().filter({
            task: 'SemPri_practice',
            accuracy: 'unanswered'
          }).count();
        var SemPri_practice_trials_accuracy_rate =
          SemPri_practice_trials_total_correct /
          (SemPri_practice_trials_total_correct +
            SemPri_practice_trials_total_incorrect +
            SemPri_practice_trials_total_unanswered);

        // Tailor message to the results. If results good, keep message short.
        if(jsPsych.data.get().filter({
            premature_response_attempts: 'yes'
          }).count() < 2 &&
          SemPri_practice_trials_accuracy_rate >= .65) {
          return '<div>Practice completed. In the next part, no feedback will be ' +
          'shown after your responses. Please press the space bar to begin.</div>'

          // If results not so good, present them
        } else {
          var message =
            '<div><b>Results of the practice</b><br>' +
            'Your accuracy rate was ' +
            Math.round(SemPri_practice_trials_accuracy_rate * 100) + '%' +
            ' (' + SemPri_practice_trials_total_correct + ' correct trials, ' +
            SemPri_practice_trials_total_incorrect + ' incorrect and ' +
            SemPri_practice_trials_total_unanswered + ' unanswered).</div>'

          // Report any premature response attempts

          if(jsPsych.data.get().filter({
              premature_response_attempts: 'yes'
            }).count() == 1) {
            var message = message +
              '<div>There was a response attempt before the lowercase word had been presented. ' +
              'Please respond only when the lowercase word appears on the screen.</div>';

          } else if(jsPsych.data.get().filter({
              premature_response_attempts: 'yes'
            }).count() > 1) {
            var message = message +
              '<div>There were ' +
              jsPsych.data.get().filter({
                premature_response_attempts: 'yes'
              }).count() +
              ' response attempts before the lowercase word had been presented. ' +
              'Please respond only when the lowercase word appears on the screen.</div>';
          }

          // Display entire message
          return message +
            '<div>Please press the space bar to repeat the practice.</div>'
        }
      }
    };
    // Add to general timeline
    language_vision_SemPri_TIMELINE.push(SemPri_practice_debrief);

    // Prepare repeated instructions
    var repeat_SemPri_instructions = {
      type: jsPsychHtmlKeyboardResponse,
      prompt: '<p>Press the space bar to begin.</p>',
      choices: [' '],
      trial_duration: 40000,
      stimulus: [
        '<div>Please consider the instructions again. Each screen will first show a word in ' +
        'upper case very briefly, and afterwards, a word in lower case. Please read both ' +
        'words, and classify the second word only as abstract or concrete. Abstract ' +
        'concepts are those that we cannot normally experience physically, whereas ' +
        'concrete concepts are those that we can experience more directly. Press ' +
        '<button>F</button> if the word is primarily abstract (for instance, <i>wait</i>), or ' +
        'press <button>J</button> if the word is primarily concrete (for instance, ' +
        '<i>water</i>). Please try to respond as accurately and fast as possible.</div>'
      ]
    };

    /* Present repeated instructions if there were any premature 
    response attempts or if accuracy rate < 65%. */
    var conditional_repeat_SemPri_instructions = {
      timeline: [repeat_SemPri_instructions],
      conditional_function: function() {
        if(jsPsych.data.get().filter({
            premature_response_attempts: 'yes'
          }).count() > 1 ||
          jsPsych.data.get().last(4).values()[0].accuracy_rate < .65) {
          return true;
        } else {
          return false
        }
      }
    };
    // Add to general timeline
    language_vision_SemPri_TIMELINE.push(conditional_repeat_SemPri_instructions);

    /* Repeat practice trials if there were any premature 
    response attempts or if accuracy rate < 65%. */
    var SemPri_repeated_practice_trials = {
      timeline: [SemPri_practice_timeline],
      data: {
        practice_round: 2
      },
      conditional_function: function() {
        if(jsPsych.data.get().filter({
            premature_response_attempts: 'yes'
          }).count() > 1 ||
          jsPsych.data.get().last(5).values()[0].accuracy_rate < .65) {
          return true;
        } else {
          return false
        }
      }
    }
    // Add to general timeline
    language_vision_SemPri_TIMELINE.push(SemPri_repeated_practice_trials);

    // Overall feedback on all the repeated practice trials
    var SemPri_repeated_practice_debrief = {
      type: jsPsychHtmlKeyboardResponse,
      choices: [' '],
      trial_duration: 20000,

      stimulus: function() {

        var SemPri_repeated_practice_trials_total_correct =
          jsPsych.data.get().filter({
            task: 'SemPri_practice',
            practice_round: 2,
            accuracy: 'correct'
          }).count();
        var SemPri_repeated_practice_trials_total_incorrect =
          jsPsych.data.get().filter({
            task: 'SemPri_practice',
            practice_round: 2,
            accuracy: 'incorrect'
          }).count();
        var SemPri_repeated_practice_trials_total_unanswered =
          jsPsych.data.get().filter({
            task: 'SemPri_practice',
            practice_round: 2,
            accuracy: 'unanswered'
          }).count();
        var SemPri_repeated_practice_trials_accuracy_rate =
          SemPri_repeated_practice_trials_total_correct /
          (SemPri_repeated_practice_trials_total_correct +
            SemPri_repeated_practice_trials_total_incorrect +
            SemPri_repeated_practice_trials_total_unanswered);

        // Tailor message introduction to the results
        if(jsPsych.data.get().filter({
            task: 'SemPri_practice',
            practice_round: 2,
            premature_response_attempts: 'yes'
          }).count() < 2 &&
          SemPri_repeated_practice_trials_accuracy_rate >= .65) {
          var message =
            '<div>Practice completed.</div>'
        } else {
          var message =
            '<div>The results were not so good. <br>Your accuracy rate was ' +
            Math.round(SemPri_repeated_practice_trials_accuracy_rate * 100) + '%' +
            ' (' + SemPri_repeated_practice_trials_total_correct + ' correct trials, ' +
            SemPri_repeated_practice_trials_total_incorrect + ' incorrect and ' +
            SemPri_repeated_practice_trials_total_unanswered + ' unanswered).' +'</div>'
        }

        // Report any premature response attempts

        if(jsPsych.data.get().filter({
            task: 'SemPri_practice',
            practice_round: 2,
            premature_response_attempts: 'yes'
          }).count() == 1) {
          var message = message +
            '<div>There was a response attempt before the lowercase word had been presented. ' +
            'Please respond only when the lowercase word appears on the screen.</div>'

        } else if(jsPsych.data.get().filter({
            task: 'SemPri_practice',
            practice_round: 2,
            premature_response_attempts: 'yes'
          }).count() > 1) {
          var message = message +
            '<div>There were ' +
            jsPsych.data.get().filter({
              task: 'SemPri_practice',
              practice_round: 2,
              premature_response_attempts: 'yes'
            }).count() +
            ' response attempts before the lowercase word had been presented. ' +
            'Please respond only when the lowercase word appears on the screen.</div>'
        }

        // Finish message
        var message = message +
          '<div> In the next part, no feedback will be shown after ' +
          'your responses. Please press the space bar to begin.</div>'

        // Display message
        return message + '<br>'
      }
    };

    // Show second-round feedback if practice trials were repeated
    var conditional_SemPri_repeated_practice_debrief = {
      timeline: [SemPri_repeated_practice_debrief],
      conditional_function: function() {
        if(jsPsych.data.get().filter({
            task: 'SemPri_practice',
            practice_round: 2
          }).count() >= 1) {
          return true;
        } else {
          return false
        }
      },
      repetitions: 1
    };
    // Add to general timeline
    language_vision_SemPri_TIMELINE.push(conditional_SemPri_repeated_practice_debrief);


    /*************************************************************************

     After the practice trials, create stimuli for the main part of the task.
    
    *************************************************************************/

    /* Merge the two variables containing the main stimuli, which 
    were separated due to the 100 MB limit of files on GitHub. */
    var SemPri_main_stimuli = SemPri_main_stimuli_1.concat(SemPri_main_stimuli_2);

    // Delete original variables
    // var SemPri_main_stimuli_1 = null;
    // var SemPri_main_stimuli_2 = null;

    // Randomly select a stimulus list for the current participant

    var list_number = SemPri_main_stimuli.map(function(el) {
      return el.list;
    });

    var random_list_number = jsPsych.randomization.sampleWithoutReplacement(list_number)[0];

    var SemPri_main_stimuli =
      SemPri_main_stimuli.filter(function(el) {
        return el.list == random_list_number
      });

    /* Set number of trials in Block 1 and in Block 2. Important: the present script 
    requires that the total number of Main stimuli (i.e., `SemPri_main_stimuli.length`) 
    and the total number of Block 1 trials (i.e., `number_of_SemPri_Block1_trials`) 
    both be even numbers. */

    var number_of_SemPri_Block1_trials = 170;
    var number_of_SemPri_Block2_trials =
      SemPri_main_stimuli.length - number_of_SemPri_Block1_trials

    /* Set time at which the second block of semantic priming should 
    finish and the last task should begin (minutes before '* 60000'). */
    var time_to_begin_last_task = 52 * 60000;


    /* Split up Abstract and Concrete trials. Next, create Block 1 by 
    selecting equal number of Abstract and Concrete trials. Last, do 
    the same to create Block 2. */

    var abstract_trials =
      SemPri_main_stimuli.filter(function(el) {
        return el.CR == 'A'
      });

    var concrete_trials =
      SemPri_main_stimuli.filter(function(el) {
        return el.CR == 'C'
      });

    var abstract_trials_Block1 =
      abstract_trials.slice(0, number_of_SemPri_Block1_trials / 2);

    var concrete_trials_Block1 =
      concrete_trials.slice(0, number_of_SemPri_Block1_trials / 2);

    var SemPri_Block1_stimuli =
      abstract_trials_Block1.concat(concrete_trials_Block1);

    var abstract_trials_Block2 =
      abstract_trials.slice((number_of_SemPri_Block1_trials / 2),
        SemPri_main_stimuli.length / 2);

    var concrete_trials_Block2 =
      concrete_trials.slice((number_of_SemPri_Block1_trials / 2),
        SemPri_main_stimuli.length / 2);

    var SemPri_Block2_stimuli =
      abstract_trials_Block2.concat(concrete_trials_Block2);


    /* Next, create set of interstimulus intervals from a range between 60 and 
    1,200 ms. First, the range is split into as many integers as the number of
    Block1 trials, equally for all participants. Afterwards, all SOAs are 
    randomised within participants. Finally, the random SOAs are repeated 
    enough times to accommodate all trials. This process ensures that the 
    range of SOAs administered to every participant includes both the minimum 
    value (60 ms) and the maximum one (1,200 ms). */

    // Create range of SOAs
    ISIntervals_main_trials = makeArr(60, 1200, number_of_SemPri_Block1_trials);

    // Randomise SOAs (hence the .5 below)
    ISIntervals_main_trials =
      ISIntervals_main_trials.sort(function() {
        return 0.5 - Math.random()
      });

    /* Repeat the random sequence of SOAs as many times as the total number of trials. 
    This caters for any Block 2 trials. */
    var ISIntervals_main_trials =
      new Array(SemPri_main_stimuli.length).fill(ISIntervals_main_trials).flat();


    /* Create timeline variables iteratively over trials using for-of loops. 
    Two preparatory steps are performed before running the loops. */

    // 1. Initialise stimuli arrays 
    SemPri_Block1_STIMULI = [];
    SemPri_Block2_STIMULI = [];

    // 2. Randomise trial order in each block

    var Block1_trial_order =
      Array.from({
        length: number_of_SemPri_Block1_trials
      }, (v, k) => k * 1);

    var randomised_Block1_trial_order =
      jsPsych.randomization.sampleWithoutReplacement(Block1_trial_order,
        number_of_SemPri_Block1_trials);

    var Block2_trial_order =
      Array.from({
        length: number_of_SemPri_Block2_trials
      }, (v, k) => k * 1);

    var randomised_Block2_trial_order =
      jsPsych.randomization.sampleWithoutReplacement(Block2_trial_order,
        number_of_SemPri_Block2_trials);

    // 3. Run loops to create Block 1 and Block 2 trials. Names of some variables are expanded.

    for (const i of randomised_Block1_trial_order) {
      SemPri_Block1_STIMULI.push({
        task: 'SemPri_main',
        prime: SemPri_Block1_stimuli[i].PW, // name changed to 'prime'
        target: SemPri_Block1_stimuli[i].TW, // name changed to 'target'
        corr_rsp: SemPri_Block1_stimuli[i].CR, // name changed to 'corr_rsp', correct response
        ISInterval: ISIntervals_main_trials[i]
      })
    }

    for (const i of randomised_Block2_trial_order) {
      SemPri_Block2_STIMULI.push({
        task: 'SemPri_main',
        prime: SemPri_Block2_stimuli[i].PW, // name changed to 'prime'
        target: SemPri_Block2_stimuli[i].TW, // name changed to 'target'
        corr_rsp: SemPri_Block2_stimuli[i].CR, // name changed to 'corr_rsp', correct response
        ISInterval: ISIntervals_main_trials[i]
      })
    }


    /* Trial numbers. jsPsych provides a 'trial_index' value in the output of the task. 
    A unique trial_index is assigned to each component of every trial (e.g., fixation,
    prime, etc.). The trial_index value is used in jsPsych functions such as `last()`, 
    which is used in this script to delimit the data to the last N trial_index values. 
    Regular trials must be manually labelled, which is done below.
    
    Important: the names of three variables used below ('prime', 'target', 'corr_rsp') 
    were set in the for loops above. */

    // Create trial numbers for Block 1

    var temp_SemPri_Block1_STIMULI = [];

    for (const i of Range(0, SemPri_Block1_STIMULI.length)) {
      temp_SemPri_Block1_STIMULI.push({
        task: 'SemPri_main',
        trial: i + 1, // 1 added to override the default beginning from 0
        prime: SemPri_Block1_STIMULI[i].prime, // prime word
        target: SemPri_Block1_STIMULI[i].target, // target word
        corr_rsp: SemPri_Block1_STIMULI[i].corr_rsp, // correct response
        ISInterval: SemPri_Block1_STIMULI[i].ISInterval
      })
    }

    var SemPri_Block1_STIMULI = temp_SemPri_Block1_STIMULI;


    // Create trial numbers for Block 2

    var temp_SemPri_Block2_STIMULI = [];

    for (const i of
        Range(0, SemPri_Block2_STIMULI.length)) {
      temp_SemPri_Block2_STIMULI.push({
        task: 'SemPri_main',
        trial: (i + 1 + // 1 added to override the default beginning from 0
          SemPri_Block1_STIMULI.length), // add number of Block 1 trials to count continuously across blocks
        prime: SemPri_Block2_STIMULI[i].prime, // prime word
        target: SemPri_Block2_STIMULI[i].target, // target word
        corr_rsp: SemPri_Block2_STIMULI[i].corr_rsp, // correct response
        ISInterval: SemPri_Block2_STIMULI[i].ISInterval
      })
    }

    var SemPri_Block2_STIMULI = temp_SemPri_Block2_STIMULI;



    /*********************************************

     Semantic priming BLOCK 1
    
    *********************************************/

    /* Assemble Block 1 timeline using some of the components 
    created near the top of this script. */

    var SemPri_Block1_timeline = {
      timeline: [ SemPri_fixation, prime, ISInterval, target_150ms, 
      target, SemPri_conditional_instructional_manipulation_check, 
      SemPri_intertrial_interval ],
      timeline_variables: SemPri_Block1_STIMULI
    };
    // Add to general timeline
    language_vision_SemPri_TIMELINE.push(SemPri_Block1_timeline);


    // Add break to general timeline
    language_vision_SemPri_TIMELINE.push(break_between_blocks);



    /*********************************************

     Semantic priming BLOCK 2
    
    *********************************************/

    // Introduce block
    var introduce_SemPri_Block2 = {
      type: jsPsychHtmlKeyboardResponse,
      trial_duration: 15000,
      choices: [' '],
      stimulus: function() {
        return '<div>Please remember: press <button>F</button> if the lowercase word ' +
          'is primarily abstract (for instance, <i>wait</i>), or press <button>J</button> ' +
          'if it is primarily concrete (for instance, <i>water</i>). <br>' +
          'Press the space bar to proceed.</div>';
      }
    };
    // Add to general timeline
    language_vision_SemPri_TIMELINE.push(introduce_SemPri_Block2);

    /* Assemble Block 2 timeline using some of the components 
    created near the top of this script. */

    var SemPri_Block2_timeline = {
      timeline: [ SemPri_fixation, prime, ISInterval, target_150ms,
      target, SemPri_conditional_instructional_manipulation_check, 
      SemPri_intertrial_interval ],
      timeline_variables: SemPri_Block2_STIMULI
    };
    // Add to general timeline
    language_vision_SemPri_TIMELINE.push(SemPri_Block2_timeline);

    // Transition to next task
    language_vision_SemPri_TIMELINE.push(break_between_tasks);



    /********************************************/
    /** VISUAL ABILITY TASK (tag: 'VisAbil')   **/
    /********************************************/

    /* This task is presented last because visually-demanding tasks can 
    increase perceptual simulation (Pecher et al., 1998; Yee et al., 2012). */

    // Push task to general timeline
    language_vision_SemPri_TIMELINE.push(VisAbil_timeline);



    /********************************************/
    /** End experiment                         **/
    /********************************************/

    var end_experiment = {
      type: jsPsychHtmlKeyboardResponse,
      choices: [' '],
      stimulus: function() {
        return '<div>The experiment has finished. <br>Thank you for your contribution!</div>';
      }
    };
    // Add to general timeline
    language_vision_SemPri_TIMELINE.push(end_experiment);



    /********************************************/
    /** Run experiment                         **/
    /********************************************/

    jsPsych.run(language_vision_SemPri_TIMELINE);

  </script>

</html>
